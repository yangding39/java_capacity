# 1.2 JMM特点

## 

### 1. Java内存模型中的重排序

* 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。

#### 1.1 重排序类型

![](//upload-images.jianshu.io/upload_images/4222138-0531c2c33ca2f3d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1025/format/webp)

* 1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
* 2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
* 3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 1.2 重排序与依赖性

* 数据依赖性  如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，这3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。

| 名称 | 代码示例 | 说明 |
| :--- | :--- | :--- |
| 写后读 | a=1; b=a; | 写一个变量后再读这个位置 |
| 写后写 | a=1;a=2; | 写一个变量后，再写这个变量； |
| 读后写 | a=b;b=1; | 读一个变量后再写这个变量 |

## Getting Super Powers

Becoming a super hero is a fairly straight forward process:

```
$ give me super-powers
```

{% hint style="info" %}
 Super-powers are granted randomly so please submit an issue if you're not happy with yours.
{% endhint %}

Once you're strong enough, save the world:

{% code title="hello.sh" %}
```bash
# Ain't no code for that yet, sorry
echo 'You got to trust me on this, I saved the world'
```
{% endcode %}



